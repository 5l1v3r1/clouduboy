#include <SPI.SCREEN_H>
#include <Wire.SCREEN_H>

#include <TinyScreen.SCREEN_H>
#include <TinyArcade.SCREEN_H>

TinyScreen display = TinyScreen(TinyScreenPlus);

#define SCREEN_W 96
#define SCREEN_H 64

// 16-bit double-buffering framebuffer
uint8_t buffer[SCREEN_W * SCREEN_H * 2];


// 16-bit color sprite
const uint16_t GFX_SONIC16[16 * 16] = {
/*16x16@16b*/   0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xa800, 0xfaaa, 0xfaaa, 0xfaaa, 0xa800, 0xfaaa, 0xa800, 0xa800, 0xa800, 0xa800, 0xfaaa, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xfaaa, 0xa800, 0x52b5, 0xa800, 0xfaaa, 0xfaaa, 0xfaaa, 0xa800, 0xfaaa, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xa800, 0xa800, 0x555f, 0x52b5, 0xa800, 0xfaaa, 0xfaaa, 0xfaaa, 0xa800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xa800, 0xa800, 0x52b5, 0x555f, 0x52b5, 0xa800, 0xfaaa, 0xfaaa, 0xfaaa, 0xa800, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xa800, 0xfaaa, 0xa800, 0x52b5, 0x555f, 0xfaaa, 0xfaaa, 0xffff, 0xfaaa, 0xfaaa, 0xfaaa, 0xa800, 0x0000, 0x0000, 0xa800, 0xa800, 0xfaaa, 0xfaaa, 0xfaaa, 0xfaaa, 0xfaaa, 0xfaaa, 0xad55, 0xffff, 0xffff, 0xfaaa, 0xfaaa, 0xa800, 0x0000, 0xa800, 0xfaaa, 0xfaaa, 0xfaaa, 0xfaaa, 0xfaaa, 0xfaaa, 0xfaaa, 0xfaaa, 0xad55, 0xffff, 0xffff, 0x0000, 0xfaaa, 0x0000, 0x0000, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0xfaaa, 0xfaaa, 0xfaaa, 0xad55, 0xffff, 0xffff, 0x0000, 0xfaaa, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xa800, 0xa800, 0xa800, 0xfaaa, 0xfaaa, 0xfaaa, 0xad55, 0xffff, 0xffff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xa800, 0xa800, 0xa800, 0xfaaa, 0x52b5, 0x52b5, 0xffff, 0xffff, 0x0000, 0x52b5, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xfaaa, 0xa800, 0xa800, 0xa800, 0x52b5, 0x555f, 0x555f, 0x555f, 0x52b5, 0x52b5, 0x555f, 0x0000, 0x0000, 0x0000, 0xa800, 0xfaaa, 0xa800, 0xa800, 0xa800, 0xa800, 0x52b5, 0x555f, 0x555f, 0x555f, 0x555f, 0x555f, 0x555f, 0x52b5, 0x0000, 0x0000, 0xa800, 0xfaaa, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0x52b5, 0x555f, 0x555f, 0x555f, 0x555f, 0x52b5, 0x0000, 0x0000, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0xa800, 0x52b5, 0x52b5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xa800, 0xa800, 0xa800, 0xa800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};

#define GFX_SONIC16_W 16
#define GFX_SONIC16_H 16

#define GFX_SONIC16_MASKCOLOR 0x0000


// Custom globals - draw starting coordinates
int sx = SCREEN_W/2;
int sy = SCREEN_H/2;


void setup() {
  arcadeInit();
  Wire.begin();

  display.begin();
  display.setFlip(0);
  display.setBrightness(8);
  display.setBitDepth(1);
}


void loop() {
  // Randomize drawing position when button 1 is pressed
  if (checkButton(TAButton1)) {
    sx = random( SCREEN_W/4, SCREEN_W/4*3 );
    sy = random( SCREEN_H/4, SCREEN_H/4*3 );
	}

  // Display graphics
  const uint16_t *gfx = GFX_SONIC16;
  for (int y = sy-GFX_SONIC16_H/2; y < sy+GFX_SONIC16_H/2; y++) {
    for (int x = sx-GFX_SONIC16_W/2; x < sx+GFX_SONIC16_W/2; x++) {
      uint16_t color = *gfx++;

      if (color != GFX_SONIC16_MASKCOLOR) {
        buffer[(x + (y * SCREEN_W)) * 2] = color >> 8;
        buffer[(x + (y * SCREEN_W)) * 2 + 1] = color;
      }
    }
  }

  // write double-buffer contents
  display.goTo(0, 0);
  display.startData();
  display.writeBuffer(buffer, SCREEN_W * SCREEN_H * 2);
  display.endTransfer();

  // clear buffer
  for (int i = 0; i < SCREEN_W * SCREEN_H * 2; i++) {
    buffer[i++] = 0;
    buffer[i] = 0;
  }
}
